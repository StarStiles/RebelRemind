/**
 * Background script for handling messages from the extension and communicating with a local server.
 *
 * Listens for messages from content scripts or popup scripts and makes API calls to a backend server.
 * Handles:
 * - Storing a count value (`POST_COUNT`)
 * - Retrieving a schedule (`GET_SCHEDULE`)
 * 
 * Authored by: Billy Estrada
 * 
 * Documentation generated by ChatGPT
 */

  /**
   * Handles requests to post a count value to the backend.
   * 
   * @param {Object} message - The message received from the content script.
   * @param {string} message.type - The type of request (should be "POST_COUNT").
   * @param {number} message.count - The count value to be sent to the server.
   * @param {Object} sender - The sender of the message (not used in this case).
   * @param {Function} sendResponse - The callback function to send the response.
   * 
   * @returns {boolean} - Returns `true` to keep `sendResponse` alive asynchronously.
   */
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === "POST_COUNT") {
    fetch("http://localhost:3001/count", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ count: message.count }),
    })
      .then((res) => res.json())
      .then((data) => sendResponse({ message: data.message }))
      .catch((err) => {
        console.error("Error posting count:", err);
        sendResponse({ message: "Error fetching data" });
      });

    return true; // Keeps sendResponse alive for asynchronous response handling
  }

  /**
   * Handles requests to fetch the user's schedule from the backend.
   * 
   * @param {Object} message - The message received from the content script.
   * @param {string} message.type - The type of request (should be "GET_SCHEDULE").
   * @param {Object} sender - The sender of the message (not used in this case).
   * @param {Function} sendResponse - The callback function to send the response.
   * 
   * @returns {boolean} - Returns `true` to keep `sendResponse` alive asynchronously.
   */
  if (message.type === "GET_SCHEDULE") {
    fetch("http://localhost:3001/schedule", {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    })
      .then((res) => res.json())
      .then((data) => sendResponse({ message: data.message }))
      .catch((err) => {
        console.error("Error fetching schedule:", err);
        sendResponse({ message: "Error fetching data" });
      });

    return true; // Keeps sendResponse alive for asynchronous response handling
  }
});
