/**
 * UserProfile.test.jsx
 *
 * This test suite verifies the behavior of the UserProfile component.
 * It checks for:
 * - Conditional rendering of user info
 * - Logout logic with proper cleanup
 * - Handling of token revocation errors
 *
 * Authored by: Sebastian Yepez
 * CODE AND DOCUMENTATION GENERATED BY CHATGPT 4o
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import UserProfile from '../components/UserProfile';
import '@testing-library/jest-dom';

// Setup global mocks
global.chrome = {
  storage: {
    sync: {
      get: jest.fn(),
      clear: jest.fn((cb) => cb?.())
    },
    local: {
      clear: jest.fn((cb) => cb?.())
    }
  },
  identity: {
    getAuthToken: jest.fn(),
    removeCachedAuthToken: jest.fn((_, cb) => cb?.())
  }
};

beforeEach(() => {
  jest.clearAllMocks();
  global.alert = jest.fn();
  global.fetch = jest.fn();
  jest.spyOn(console, 'error').mockImplementation(() => {});
  jest.spyOn(console, 'log').mockImplementation(() => {});
});

describe('UserProfile Component', () => {
  test('displays fallback when no user is logged in', async () => {
    chrome.storage.sync.get.mockImplementation((keys, cb) => cb({}));

    render(<UserProfile />);
    expect(await screen.findByText(/no user logged in/i)).toBeInTheDocument();
  });

  test('renders user information when user is present', async () => {
    const mockUser = {
      name: 'Sebastian Yepez',
      email: 'seb@example.com',
      picture: 'https://example.com/avatar.png',
    };

    chrome.storage.sync.get.mockImplementation((keys, cb) => cb({ user: mockUser }));

    render(<UserProfile />);
    expect(await screen.findByText(mockUser.name)).toBeInTheDocument();
    expect(screen.getByText(mockUser.email)).toBeInTheDocument();
    expect(screen.getByAltText(/profile picture/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /logout/i })).toBeInTheDocument();
  });

  test('handles logout success path correctly', async () => {
    chrome.storage.sync.get.mockImplementation((keys, cb) => {
      cb({
        user: {
          name: 'Test User',
          email: 'test@example.com',
          picture: '',
        }
      });
    });

    chrome.identity.getAuthToken.mockImplementation((_, cb) => cb('mock_token'));
    global.fetch.mockResolvedValue({ ok: true });

    render(<UserProfile />);
    fireEvent.click(await screen.findByText(/logout/i));

    await waitFor(() => {
      expect(chrome.identity.getAuthToken).toHaveBeenCalled();
      expect(chrome.identity.removeCachedAuthToken).toHaveBeenCalledWith({ token: 'mock_token' }, expect.any(Function));
      expect(chrome.storage.sync.clear).toHaveBeenCalled();
      expect(chrome.storage.local.clear).toHaveBeenCalled();
      expect(global.alert).toHaveBeenCalledWith('You have been logged out.');
    });
  });

  test('handles token revocation error gracefully', async () => {
    chrome.storage.sync.get.mockImplementation((keys, cb) => {
      cb({
        user: {
          name: 'Error User',
          email: 'error@example.com',
          picture: '',
        }
      });
    });

    chrome.identity.getAuthToken.mockImplementation((_, cb) => cb('mock_token'));
    global.fetch.mockRejectedValue(new Error('Revoke failed'));
    const errorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

    render(<UserProfile />);
    fireEvent.click(await screen.findByText(/logout/i));

    await waitFor(() => {
      expect(errorSpy).toHaveBeenCalledWith('Failed to revoke token', expect.any(Error));
    });

    errorSpy.mockRestore();
  });
});
