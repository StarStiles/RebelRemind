/**
 * UserProfile.test.jsx
 *
 * This test suite verifies the functionality of the UserProfile component,
 * which loads authenticated user data and preferences from Chrome storage,
 * renders subcomponents, and handles logout (including token revocation).
 *
 * Features tested:
 * - Conditional rendering based on user presence
 * - Integration with Preferences and CanvasTokenManager components
 * - Logout logic, including:
 *   - Clearing chrome.storage
 *   - Revoking OAuth token via fetch
 *   - Handling token revocation failures
 * 
 * CODE AND DOCUMENTATION GENERATED BY CHATGPT 4o
 * Authored by: Sebastian Yepez
 * 
 */

import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import UserProfile from '../components/UserProfile';
import '@testing-library/jest-dom';

/**
 * Mocks for child components and Chrome Extension APIs:
 * - Preferences and CanvasTokenManager are mocked to avoid unrelated logic
 * - chrome.storage.sync.get simulates stored user data and preferences
 * - chrome.identity handles token revocation
 */
jest.mock('../components/Preferences', () => jest.fn(() => <div data-testid="mock-preferences" />));
jest.mock('../components/CanvasTokenManager', () => jest.fn(() => <div data-testid="mock-canvas-manager" />));

global.chrome = {
  storage: {
    sync: {
      get: jest.fn(),
      clear: jest.fn((callback) => callback && callback()),
    },
    local: {
      clear: jest.fn((callback) => callback && callback()),
    },
  },
  identity: {
    getAuthToken: jest.fn(),
    removeCachedAuthToken: jest.fn((_, cb) => cb && cb()),
  },
};

beforeEach(() => {
  jest.clearAllMocks();
  global.alert = jest.fn(); // suppress alert
});

describe('UserProfile', () => {
  /**
   * Test: Fallback UI when no user is logged in
   *
   * Verifies that the component displays a message when user data
   * is not available from chrome.storage.
   */
  test('renders fallback message when no user is logged in', async () => {
    chrome.storage.sync.get.mockImplementation((keys, callback) => {
      callback({}); // Simulate no user
    });

    render(<UserProfile />);

    await waitFor(() => {
      expect(screen.getByText('No user logged in.')).toBeInTheDocument();
    });
  });

  /**
   * Test: Renders user UI when user and preferences are found
   *
   * Confirms that:
   * - Preferences component is rendered
   * - CanvasTokenManager is rendered
   * - Logout button is present
   */
  test('loads and displays user profile with Preferences and CanvasTokenManager', async () => {
    const mockUser = {
      name: 'Test User',
      email: 'test@example.com',
      picture: 'https://example.com/test.jpg',
    };
    const mockPrefs = {
      darkMode: true,
      notifications: false,
      canvasIntegration: true,
    };

    chrome.storage.sync.get.mockImplementation((keys, callback) => {
      callback({ user: mockUser, preferences: mockPrefs });
    });

    render(<UserProfile />);

    await waitFor(() => {
      expect(screen.getByTestId('mock-preferences')).toBeInTheDocument();
      expect(screen.getByTestId('mock-canvas-manager')).toBeInTheDocument();
      expect(screen.getByText('Logout')).toBeInTheDocument();
    });
  });

  /**
   * Test: Handles token revocation failure gracefully
   *
   * Simulates a failed fetch call during logout and checks that
   * the error is caught and logged.
   */
  test('logs error if token revocation fails', async () => {
    chrome.storage.sync.get.mockImplementation((keys, callback) => {
      callback({
        user: {
          name: 'Test User',
          email: 'test@example.com',
        },
        preferences: {
          darkMode: false,
          notifications: false,
          canvasIntegration: false,
        },
      });
    });

    chrome.identity.getAuthToken.mockImplementation((opts, callback) => {
      callback('mock_token');
    });

    // Simulate fetch failure
    global.fetch = jest.fn(() => Promise.reject(new Error('Network error')));
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

    render(<UserProfile />);
    await waitFor(() => screen.getByText('Logout'));

    fireEvent.click(screen.getByText('Logout'));

    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Failed to revoke token',
        expect.any(Error)
      );
    });

    consoleErrorSpy.mockRestore();
  });

  /**
   * Test: Full logout flow (happy path)
   *
   * Verifies:
   * - OAuth token is retrieved and revoked
   * - chrome storage is cleared
   * - User is logged out and alert is shown
   */
  test('handles logout correctly', async () => {
    chrome.storage.sync.get.mockImplementation((keys, callback) => {
      callback({
        user: {
          name: 'Test User',
          email: 'test@example.com',
        },
        preferences: {
          darkMode: false,
          notifications: false,
          canvasIntegration: false,
        },
      });
    });

    chrome.identity.getAuthToken.mockImplementation((opts, callback) => {
      callback('mock_token');
    });

    // Simulate successful revocation
    global.fetch = jest.fn(() => Promise.resolve({ ok: true }));

    render(<UserProfile />);
    await waitFor(() => screen.getByText('Logout'));

    fireEvent.click(screen.getByText('Logout'));

    await waitFor(() => {
      expect(chrome.identity.getAuthToken).toHaveBeenCalled();
      expect(chrome.identity.removeCachedAuthToken).toHaveBeenCalledWith(
        { token: 'mock_token' },
        expect.any(Function)
      );
      expect(chrome.storage.sync.clear).toHaveBeenCalled();
      expect(chrome.storage.local.clear).toHaveBeenCalled();
      expect(global.alert).toHaveBeenCalledWith('You have been logged out.');
    });
  });
});
