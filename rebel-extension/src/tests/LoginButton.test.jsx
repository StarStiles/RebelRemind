/**
 * LoginButton.test.jsx
 *
 * This test suite verifies the behavior of the LoginButton component,
 * which initiates Google OAuth login through the Chrome Extension API.
 *
 * Features tested:
 * - UI rendering of the login button
 * - Successful login logic (calls to chrome.runtime and chrome.storage)
 * - Failed login behavior (error message rendering)
 * 
 * CODE AND DOCUMENTATION GENERATED BY CHATGPT 4o
 * Authored by: Sebastian Yepez
 * 
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import LoginButton from '../components/LoginButton';
import '@testing-library/jest-dom';

/**
 * Mocks for Chrome Extension APIs:
 * - chrome.runtime.sendMessage: for triggering login requests
 * - chrome.storage.sync.set: for storing user information
 */
global.chrome = {
  runtime: {
    sendMessage: jest.fn(),
  },
  storage: {
    sync: {
      set: jest.fn(),
    },
  },
};

describe('LoginButton', () => {
  beforeEach(() => {
    jest.clearAllMocks(); // Ensure clean state between tests
    jest.spyOn(console, 'error').mockImplementation(() => {}); // Silence expected errors
  });

  /**
   * Test: UI renders login button
   * 
   * Verifies that the component initially renders a button labeled
   * "Login with Google".
   */
  test('renders login button', () => {
    render(<LoginButton />);
    expect(screen.getByText('Login with Google')).toBeInTheDocument();
  });

  /**
   * Test: Successful login flow
   * 
   * Simulates a successful response from the background script.
   * Ensures:
   * - chrome.runtime.sendMessage is called with correct message
   * - chrome.storage.sync.set is called to store user data
   */
  test('handles successful login', async () => {
    const mockUser = { name: 'Test User', email: 'test@example.com' };

    chrome.runtime.sendMessage.mockImplementation((msg, callback) => {
      callback({ success: true, user: mockUser });
    });

    render(<LoginButton />);
    fireEvent.click(screen.getByText('Login with Google'));

    await waitFor(() => {
      expect(chrome.runtime.sendMessage).toHaveBeenCalledWith(
        { type: 'LOGIN' },
        expect.any(Function)
      );
      expect(chrome.storage.sync.set).toHaveBeenCalledWith({ user: mockUser });
    });
  });

  /**
   * Test: Failed login flow
   * 
   * Simulates an unsuccessful login attempt and verifies:
   * - An error message is displayed to the user
   * - chrome.runtime.sendMessage was still called
   */
  test('handles failed login and displays error message', async () => {
    const mockError = 'Authentication failed.';

    chrome.runtime.sendMessage.mockImplementation((msg, callback) => {
      callback({ success: false, error: mockError });
    });

    render(<LoginButton />);
    fireEvent.click(screen.getByText('Login with Google'));

    await waitFor(() => {
      expect(screen.getByText(mockError)).toBeInTheDocument();
      expect(chrome.runtime.sendMessage).toHaveBeenCalled();
    });
  });
});
